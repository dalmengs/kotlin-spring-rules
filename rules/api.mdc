---
alwaysApply: true
---

# API Writing Conventions (Spring Boot + Kotlin)

This rule defines **end-to-end API writing conventions** for this repository: project structure, Controller/Service/DTO/Exception/Entity rules, and usage guidelines for shared abstractions.

> DB/Repository/QueryDSL/JPA/PagingHandler 내부 구현 규칙은 `rules/database.mdc` 를 **반드시 참고**하세요.  
> This document focuses on API-layer rules and correct usage. DB internals belong to `rules/database.mdc`.

---

## AI Behavior Guidelines

When implementing or reviewing API code, you MUST:

1. **Identify the layer first**: Controller / Service / DTO / Exception / Entity
2. **Follow the rules of that layer strictly**
3. **If requirements are unclear**, default to the safest convention:
   - collection endpoints → paging by default
   - all responses → `BaseResponse<T>`
   - all resource identifiers → external `id: String` only (never `seq`)

---

## Project structure (Domain-first)

### Domain-first package layout 
- **MUST**: Split code by domain.
- **MUST**: Each domain must follow the same internal folder layout. (도메인마다 동일한 위치/역할)

```
src/main/kotlin/com/dalmeng/convention/
├── common/
│   ├── entity/        # BaseEntity
│   ├── exception/     # BaseException, GlobalExceptionHandler
│   ├── paging/        # BasePagingRequest, PagingResponse, PagingService
│   └── response/      # BaseResponse, ErrorResponse
└── {domain}/
    ├── controller/
    ├── service/
    ├── repository/
    ├── entity/
    ├── dto/
    │   ├── request/
    │   └── response/
    ├── exception/
    └── paging/
```

### Dependency direction / 의존성 방향
- **MUST**: Keep a one-way dependency: `controller → service → repository`.
- **MUST NOT**: Do not mutate another domain’s `entity` directly from your Controller/Service. Use that domain’s Service/QueryRepository when needed.
- **MUST NOT**: Never return JPA entities from API endpoints.

---

## Common response rules / 공통 응답 규칙

### Always wrap responses with BaseResponse
- **MUST**: Controller return type must always be `BaseResponse<T>`.
- **MUST**: For success responses, use `BaseResponse.ok(data = ...)`.
- **MUST NOT**: Do not manually construct `ResponseEntity` in Controllers.
  - Exception: file downloads/streams or other non-JSON responses.

Reference:
- `com.dalmeng.convention.common.response.BaseResponse`
- `com.dalmeng.convention.common.response.ErrorResponse`

### BaseResponse field semantics
- **statusCode**: HTTP status code to return (e.g. 200, 400, 404)
- **message**: human-readable message (`"Succeed"` / `"Failed"` by default)
- **data**: payload for success responses
- **error**: payload for error responses (`ErrorResponse(message)`)

---

## API URI conventions

### Base principles
- **MUST**: Use nouns only. (No verbs in paths)  
- **MUST**: Use lowercase paths. (e.g. `/chatroom`, `/chat`)
- **MUST**: Accept resource identifiers via path variables. (e.g. `/{id}`)
- **MUST NOT**: Never accept `seq` via path/query/body.
- **SHOULD**: Match existing codebase style: singular base paths (e.g. `/chatroom`, `/character`).
- **SHOULD**: For multi-word resources, use hyphen: `/user-profile` (avoid underscores).

### Nested resources 
- **SHOULD**: Keep nesting shallow (max depth 2).
- **MUST**: Nest only when ownership/scope is unambiguous.

Examples:
- `GET /chatroom/{id}`: find one chatroom 
- `GET /chat/chatroom/{chatroomId}`: chat records of the chatroom with paging

---

## HTTP method semantics

### GET (Read)
- **MUST**: Use GET for reads only.
- **MUST NOT**: Reads must not change server state.

### POST (Create)
- **MUST**: Use POST for creation only.
- **MUST**: Request body must be defined as `dto/request/CreateXRequest`.

### PATCH (Partial Update)
- **MUST**: Use PATCH for partial updates.
- **MUST**: PATCH request DTO fields must be **all nullable** (enforces partial update).
- **MUST**: Apply updates inside the **Entity’s update method**, not in the Service.

### DELETE (Delete)
- **MUST**: Use DELETE for deletion.
- **SHOULD**: Prefer soft delete when applicable. (DB rules: `rules/database.mdc`)

---

## Controller layer conventions

### Responsibilities
- **MUST**: Controllers are thin HTTP adapters (binding + response shape only).
- **MUST**: Delegate all business logic to the Service layer.
- **MUST NOT**: Do not handle exceptions with try/catch in Controllers (Global handler converts exceptions).

### Required parameters
- **MUST**: Receive user identity as an HTTP header.
  - Header name: **`X-User-Id`**
  - Signature example: `@RequestHeader("X-User-Id") userId: String`
- **MUST**: Pass `userId` to Service as-is.
- **MUST NOT**: Do not implement authentication/authorization logic in Controllers.
- **SHOULD**: Only allow `userId: String?` for explicitly “optional login” endpoints.

### Always define request/response DTOs
- **MUST**: Define request and response DTOs for every endpoint.
  - Exception: body-less GET/DELETE may use only path/query parameters.
- **MUST NOT**: Never use Entities as request/response models.

### Single resource / 단건 조회
- **MUST**: `GET /{resource}/{id}`
- **MUST**: `id` must be the external identifier (`id: String`), not `seq`.

### Collections — paging by default / 다건 조회(기본 페이징)
- **MUST**: If not explicitly requested otherwise, collection reads must use paging.
- **MUST**: Accept paging input via `@ModelAttribute request: BasePagingRequest`.
- **MUST**: Return `BaseResponse<PagingResponse<ResponseDto>>`.

참고 구현 / References:
- `com.dalmeng.convention.common.paging.BasePagingRequest`
- `com.dalmeng.convention.common.paging.PagingResponse`

### Paging usage rules
- **MUST**: Controllers must bind paging params via `@ModelAttribute` only.
- **MUST**: Services must call `request.validate()` early to enforce valid paging combinations.

### Standard controller template

```kotlin
@RestController
@RequestMapping("/resources")
class ResourceController(
    private val resourceService: ResourceService,
) {
    @PostMapping
    fun create(
        @RequestHeader("X-User-Id") userId: String,
        @RequestBody request: CreateResourceRequest,
    ): BaseResponse<ResourceResponse> =
        BaseResponse.ok(data = resourceService.create(userId, request))

    @GetMapping("/{id}")
    fun getById(
        @RequestHeader("X-User-Id") userId: String,
        @PathVariable id: String,
    ): BaseResponse<ResourceResponse> =
        BaseResponse.ok(data = resourceService.findById(userId, id))

    @GetMapping
    fun getAllPaging(
        @RequestHeader("X-User-Id") userId: String,
        @ModelAttribute request: BasePagingRequest,
    ): BaseResponse<PagingResponse<ResourceResponse>> =
        BaseResponse.ok(data = resourceService.findAll(userId, request))

    @PatchMapping("/{id}")
    fun update(
        @RequestHeader("X-User-Id") userId: String,
        @PathVariable id: String,
        @RequestBody request: UpdateResourceRequest,
    ): BaseResponse<ResourceResponse> =
        BaseResponse.ok(data = resourceService.update(userId, id, request))

    @DeleteMapping("/{id}")
    fun delete(
        @RequestHeader("X-User-Id") userId: String,
        @PathVariable id: String,
    ): BaseResponse<Nothing> =
        BaseResponse.ok(data = null)
}
```

---

## Exception conventions

### Principles
- **MUST**: Represent expected failures (domain rule violations, missing resources, forbidden access) as custom exceptions.
- **MUST**: Place domain exceptions under `{domain}/exception/`.
- **MUST**: Domain exceptions must extend `BaseException(statusCode, message)`.
- **MUST NOT**: Do not add “meaningless” try/catch in Controller/Service (let the global handler convert).
- **MUST NOT**: Never swallow exceptions (log-only + return success).

참고 구현 / References:
- `com.dalmeng.convention.common.exception.BaseException`
- `com.dalmeng.convention.common.exception.GlobalExceptionHandler`

### Naming
- **MUST**: `XNotFoundException` (404)
- **MUST**: `InvalidXRequestException` / `InvalidXException` (400)
- **SHOULD**: `XForbiddenException` (403), `XUnauthorizedException` (401), `XConflictException` (409)

### Status code guide / 상태코드 가이드
- **400**: validation failures, invalid request combinations, input-level domain rule violations
- **401**: authentication required (missing token/header) — apply per project policy
- **403**: forbidden (ownership mismatch, no permission)
- **404**: resource not found
- **409**: conflict (duplicate creation, state conflict)
- **500**: unexpected errors (handled by the global handler)

---

## Service layer conventions 

### Responsibilities
- **MUST**: Implement all business logic in Services.
- **MUST**: Enforce ownership/authorization checks in Services (e.g., compare `userId` with resource owner).
- **MUST NOT**: Never return Entities from Services; return DTOs only.

### Transactions
- **MUST**: Use `@Transactional` for create/update/delete.
- **MUST**: Use `@Transactional(readOnly = true)` for reads.
- **MUST NOT**: Do not put transactions on Controllers.

> Repository/QueryRepository 트랜잭션/쿼리 규칙은 `rules/database.mdc` 를 따릅니다.

### Function signature & naming
- **MUST**: For user-scoped APIs, `userId` must be the first parameter.
- **SHOULD**: Single read: `findXById(userId, id)`
- **SHOULD**: Paged collection read: `findXs(userId, request)`
- **MUST**: Create: `createX(userId, request)`
- **MUST**: Update: `updateX(userId, id, request)`
- **MUST**: Delete: `deleteX(userId, id)`

### Paging in Services
- **MUST**: Use `PagingService.paginate(request, handlers)`.
- **MUST**: Always convert to DTO via `pagingService.map(...)` (never return `PagingResponse<Entity>`).
- **MUST**: Implement handlers/repositories/queries by following `rules/database.mdc` (do not duplicate DB internals here).

Example:

```kotlin
@Transactional(readOnly = true)
fun findXs(userId: String, request: BasePagingRequest): PagingResponse<XResponse> {
    request.validate()
    val handlers = XPagingHandlers(/* ... */)
    val entities = pagingService.paginate(request = request, handlers = handlers)
    return pagingService.map(entities) { XResponse.from(it) }
}
```

---

## DTO conventions

### Folder layout
- **MUST**: 도메인 하위에 `dto/request`, `dto/response`를 둡니다.

```
{domain}/dto/
├── request/
│   ├── CreateXRequest.kt
│   └── UpdateXRequest.kt
└── response/
    └── XResponse.kt
```

### Request DTO rules

#### Create Request
- **MUST**: Required fields must be non-null.
- **SHOULD**: Use `spring-boot-starter-validation` annotations when validation is needed.
  - Examples: `@field:NotBlank`, `@field:Size`, `@field:NotNull`
- **SHOULD**: Validate in Controllers via `@Valid`.

#### Patch(Update) Request
- **MUST**: All fields must be nullable.
- **MUST**: Pass nullable fields into `entity.update(...)`; the Entity applies them with `?.let {}`.

### Response DTO rules
- **MUST**: Response DTOs must contain only API-safe fields.
- **MUST NOT**: Never include the internal DB PK `seq`.
- **MUST NOT**: Never embed JPA Entities inside Response DTOs.
- **MUST**: Use `companion object { fun from(entity) }` for mapping.

### Optional fields (flexibility)
- **MUST**: If a field may be omitted depending on context, model it as nullable in the Response DTO.
- **SHOULD**: Add overloads/flags when needed.
  - Example: `from(entity)` / `from(entity, includeDetails = true)`

---

## Entity conventions

### BaseEntity inheritance / BaseEntity 상속
- **MUST**: All entities must extend `com.dalmeng.convention.common.entity.BaseEntity` and consistently use:
  - `seq: Long` (internal PK, never exposed)
  - `id: String` (external identifier, API-facing)
  - `createdAt`, `updatedAt`

> `com.dalmeng.convention.common.response.BaseEntity` 는 사용하지 않습니다.  
> Use `common.entity.BaseEntity` as the single source of truth.

### JPA relations
- **MUST**: All relations must use `FetchType.LAZY`.
- **MUST NOT**: `EAGER` is forbidden.

### Where business logic lives
- **MUST**: Put state-changing logic (updates, delete flags, relationship mutations) inside Entity methods.
- **MUST NOT**: Do not directly mutate Entity fields from Services.

### Creation & invariants
- **MUST**: Use `companion object.create(...)` as the creation factory.
- **SHOULD**: Enforce invariants/validation inside the Entity (Services orchestrate use-cases).

---

## Out of scope

This rule does not define below directly:

- **DB/Repository/QueryDSL/JPA/PagingHandlers Implementation Details** → `rules/database.mdc`
- **Common Implementation details** → for abstraction, this defines only “How to use”.

